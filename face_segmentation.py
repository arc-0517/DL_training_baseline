# -*- coding: utf-8 -*-
"""face_segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u8oJhd1JBb_c4vJGatrdZ-fNNu69x-y5

# 얼굴 세그멘테이션과 마스킹 실습

## 학습 내용
1. SegFormer 모델을 사용한 얼굴 파싱(Face Parsing)
2. 얼굴의 특정 부위(눈, 코, 입 등) 마스킹
3. 관심 영역(ROI) 추출 및 크롭
4. 마스킹된 이미지 저장 및 시각화

### Step 1: 환경 설정 및 라이브러리 설치
"""

# 필요한 라이브러리 설치
!pip install transformers torch pillow matplotlib requests -q

# 라이브러리 임포트
from transformers import SegformerImageProcessor, SegformerForSemanticSegmentation
from PIL import Image, ImageDraw
import torch
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import os

from google.colab import drive
drive.mount('/content/drive')

"""### Step 2: 모델 로드 및 기본 설정

**사용 모델**: `jonathandinu/face-parsing`
- SegFormer 기반의 얼굴 파싱 모델
- 19개 클래스로 얼굴 영역 분류
"""

# 모델 및 프로세서 로드
print("모델 로딩 중...")
processor = SegformerImageProcessor.from_pretrained("jonathandinu/face-parsing")
model = SegformerForSemanticSegmentation.from_pretrained("jonathandinu/face-parsing")

# GPU 사용 설정
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)
model.eval()

print(f"모델 로드 완료 (Device: {device})")

# 원본 얼굴 파싱 라벨 정의 (19개 클래스)
ORIGINAL_LABELS = {
    'background': 0,   # 배경
    'skin': 1,         # 피부
    'l_brow': 2,       # 왼쪽 눈썹
    'r_brow': 3,       # 오른쪽 눈썹
    'l_eye': 4,        # 왼쪽 눈
    'r_eye': 5,        # 오른쪽 눈
    'eye_g': 6,        # 안경
    'l_ear': 7,        # 왼쪽 귀
    'r_ear': 8,        # 오른쪽 귀
    'ear_r': 9,        # 귀걸이 (사용 안 함)
    'nose': 10,        # 코
    'mouth': 11,       # 입
    'u_lip': 12,       # 윗입술
    'l_lip': 13,       # 아랫입술
    'neck': 14,        # 목
    'neck_l': 15,      # 목걸이 (사용 안 함)
    'cloth': 16,       # 옷 (사용 안 함)
    'hair': 17,        # 머리카락
    'hat': 18          # 모자 (사용 안 함)
}

# 단순화된 라벨 정의 (10개 클래스)
SIMPLIFIED_LABELS = {
    'background': 0,
    'skin': 1,
    'eyebrow': 2,      # 왼쪽/오른쪽 통합
    'eye': 3,          # 왼쪽/오른쪽 통합
    'eye_g': 4,        # 안경
    'ear': 5,          # 왼쪽/오른쪽 통합
    'nose': 6,
    'mouth': 7,        # 입 + 윗입술 + 아랫입술 통합
    'neck': 8,
    'hair': 9
}

# 원본 라벨 → 단순화 라벨 매핑
LABEL_MAPPING = {
    0: 0,   # background → background
    1: 1,   # skin → skin
    2: 2,   # l_brow → eyebrow
    3: 2,   # r_brow → eyebrow
    4: 3,   # l_eye → eye
    5: 3,   # r_eye → eye
    6: 4,   # eye_g → eye_g
    7: 5,   # l_ear → ear
    8: 5,   # r_ear → ear
    9: 0,   # ear_r → background (제외)
    10: 6,  # nose → nose
    11: 7,  # mouth → mouth
    12: 7,  # u_lip → mouth
    13: 7,  # l_lip → mouth
    14: 8,  # neck → neck
    15: 0,  # neck_l → background (제외)
    16: 0,  # cloth → background (제외)
    17: 9,  # hair → hair
    18: 0   # hat → background (제외)
}

# 단순화 라벨 이름
SIMPLIFIED_LABEL_NAMES = {v: k for k, v in SIMPLIFIED_LABELS.items()}

print("라벨 정의 완료")
print(f"\n원본 라벨: {len(ORIGINAL_LABELS)}개")
print(f"단순화 라벨: {len(SIMPLIFIED_LABELS)}개\n")

print("단순화된 얼굴 파싱 라벨:")
for idx, name in SIMPLIFIED_LABEL_NAMES.items():
    print(f"  {idx}: {name}")

"""### Step 3: 이미지 로드 및 확인"""

# 이미지 경로 설정 (본인의 경로로 수정)
IMAGE_PATH = "/content/drive/MyDrive/dataset/data_06/Training/01.원천데이터/TS_건선_정면/H0_115008_P7_L1.png"

# 이미지 로드
image = Image.open(IMAGE_PATH).convert("RGB")

print(f"이미지 크기: {image.size}")
print(f"이미지 모드: {image.mode}")

# 이미지 표시
plt.figure(figsize=(5, 5))
plt.imshow(image)
plt.title("origin image")
plt.axis('off')
plt.show()

"""### Step 4: Face Parsing 수행
얼굴 이미지의 각 픽셀을 19개 클래스 중 하나로 분류
"""

def parse_face(image):
    """
    얼굴 이미지를 파싱하여 단순화된 세그멘테이션 맵 생성

    Args:
        image: PIL Image 객체

    Returns:
        parsing: numpy array (H, W) - 단순화된 클래스 레이블 (0-9)
    """
    # 이미지 전처리
    inputs = processor(images=image, return_tensors="pt").to(device)

    # 모델 추론
    with torch.no_grad():
        outputs = model(**inputs)

    # 출력 로짓을 원본 이미지 크기로 업샘플링
    logits = outputs.logits
    upsampled_logits = torch.nn.functional.interpolate(
        logits,
        size=image.size[::-1],  # (height, width)
        mode="bilinear",
        align_corners=False
    )

    # 가장 높은 확률의 클래스 선택 (원본 19개 클래스)
    original_parsing = upsampled_logits.argmax(dim=1)[0].cpu().numpy()

    # 단순화된 라벨로 변환 (19개 → 10개)
    simplified_parsing = np.zeros_like(original_parsing)
    for original_label, simplified_label in LABEL_MAPPING.items():
        simplified_parsing[original_parsing == original_label] = simplified_label

    return simplified_parsing

# Face parsing 수행
print("Face parsing 수행 중...")
parsing_map = parse_face(image)

print(f"\nParsing 완료")
print(f"Parsing map 크기: {parsing_map.shape}")
print(f"검출된 클래스: {np.unique(parsing_map)}")
print(f"\n각 클래스별 픽셀 수:")
for label_id in np.unique(parsing_map):
    label_name = SIMPLIFIED_LABEL_NAMES.get(label_id, 'unknown')
    pixel_count = np.sum(parsing_map == label_id)
    percentage = (pixel_count / parsing_map.size) * 100
    print(f"  {label_id} ({label_name:10s}): {pixel_count:7d} pixels ({percentage:5.2f}%)")

"""## Step 5: Parsing 결과 시각화

각 얼굴 부위를 다른 색상으로 표시
"""

def visualize_parsing(image, parsing_map, alpha=0.6):
    """
    Face parsing 결과를 시각화

    Args:
        image: 원본 PIL Image
        parsing_map: parsing 결과 (numpy array)
        alpha: 오버레이 투명도 (0~1)
    """
    # 10개 클래스를 위한 컬러맵 생성
    num_classes = 10
    colors = plt.cm.tab10(np.linspace(0, 1, num_classes))

    # Parsing map을 RGB로 변환
    parsing_rgb = colors[parsing_map][:, :, :3]  # RGBA에서 RGB만 사용

    # 원본 이미지와 합성
    img_array = np.array(image) / 255.0
    overlay = alpha * parsing_rgb + (1 - alpha) * img_array
    overlay = np.clip(overlay, 0, 1)

    # 시각화
    fig, axes = plt.subplots(1, 3, figsize=(10, 5))

    # 원본 이미지
    axes[0].imshow(image)
    axes[0].set_title('origin image', fontsize=14, fontweight='bold')
    axes[0].axis('off')

    # Parsing map
    axes[1].imshow(parsing_rgb)
    axes[1].set_title('Parsing Map - 10 labels', fontsize=14, fontweight='bold')
    axes[1].axis('off')

    # 오버레이
    axes[2].imshow(overlay)
    axes[2].set_title('overlay image', fontsize=14, fontweight='bold')
    axes[2].axis('off')

    plt.tight_layout()
    plt.show()


# 시각화 실행
visualize_parsing(image, parsing_map)

"""## Step 6: 특정 부위 마스킹

6-1. 눈과 입 마스킹
"""

def mask_regions(image, parsing_map, mask_labels, mask_color=(0, 0, 0)):
    """
    특정 영역을 마스킹 (검은색 또는 지정 색상으로 채움)

    Args:
        image: 원본 PIL Image
        parsing_map: face parsing 결과
        mask_labels: 마스킹할 라벨 리스트
        mask_color: 마스킹 색상 (R, G, B)

    Returns:
        masked_image: 마스킹된 PIL Image
    """
    # 이미지를 numpy array로 변환
    img_array = np.array(image).copy()

    # 마스킹할 영역 찾기
    mask = np.isin(parsing_map, mask_labels)

    # 마스킹 적용
    img_array[mask] = mask_color

    # PIL Image로 변환
    masked_image = Image.fromarray(img_array)

    return masked_image

# 눈과 입, 머리카락 마스킹
mask_labels = [
    SIMPLIFIED_LABELS['eye'],      # 눈
    SIMPLIFIED_LABELS['mouth'],     # 입
    SIMPLIFIED_LABELS['hair']     # 머리카락
]

masked_image = mask_regions(image, parsing_map, mask_labels, mask_color=(0, 0, 0))

# 결과 비교
fig, axes = plt.subplots(1, 2, figsize=(8, 4))

axes[0].imshow(image)
axes[0].set_title('origin image', fontsize=14, fontweight='bold')
axes[0].axis('off')

axes[1].imshow(masked_image)
axes[1].set_title('masking image', fontsize=14, fontweight='bold')
axes[1].axis('off')

plt.tight_layout()
plt.show()

"""6-2. 피부만 필터링"""

# 피부만 남기고 나머지는 모두 검은색으로
img_array = np.array(image).copy()

# 피부 영역만 True인 마스크 생성
skin_mask = (parsing_map == SIMPLIFIED_LABELS['skin'])

# 피부가 아닌 부분을 검은색으로
img_array[~skin_mask] = 0

skin_only_image = Image.fromarray(img_array)

# 시각화
fig, axes = plt.subplots(1, 2, figsize=(8, 4))

axes[0].imshow(image)
axes[0].set_title('origin image', fontsize=14, fontweight='bold')
axes[0].axis('off')

axes[1].imshow(skin_only_image)
axes[1].set_title('skin extraction', fontsize=14, fontweight='bold')
axes[1].axis('off')

plt.tight_layout()
plt.show()

"""## Step 7: 마스킹 결과 저장

처리된 이미지를 파일로 저장
"""

# 출력 디렉토리 생성
output_dir = "face_masking_results"
os.makedirs(output_dir, exist_ok=True)

print(f"출력 디렉토리: {output_dir}")
print("\n파일 저장 중...\n")

# 마스킹 이미지 저장
masked_path = os.path.join(output_dir, "masked_image.jpg")
masked_image.save(masked_path)
print(f"✓ {masked_path}")


# 스킨 필터링 이미지 저장
skin_filter_path = os.path.join(output_dir, "skin_filter_image.jpg")
skin_only_image.save(skin_filter_path)
print(f"✓ {skin_filter_path}")

